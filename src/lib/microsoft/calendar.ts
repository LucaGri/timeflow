import { supabase, Event as EventType } from '@/lib/supabase'
import { getValidMicrosoftToken } from './auth'
import { format, parseISO } from 'date-fns'

const GRAPH_API_BASE = 'https://graph.microsoft.com/v1.0'

/**
 * Microsoft Graph API Error
 */
class MicrosoftGraphError extends Error {
  constructor(message: string, public statusCode?: number) {
    super(message)
    this.name = 'MicrosoftGraphError'
  }
}

/**
 * Handle Microsoft Graph API errors
 */
const handleGraphError = async (response: Response) => {
  let errorMessage = `Microsoft Graph API error: ${response.status}`

  try {
    const errorData = await response.json()
    if (errorData.error?.message) {
      errorMessage = errorData.error.message
    }
  } catch {
    // If we can't parse error, use status text
    errorMessage = `${response.status} ${response.statusText}`
  }

  throw new MicrosoftGraphError(errorMessage, response.status)
}

/**
 * Get events from Microsoft Calendar
 * @param startDate - Start date for event range
 * @param endDate - End date for event range
 * @returns Array of events in TimeFlow format
 */
export const getMicrosoftEvents = async (
  startDate: Date,
  endDate: Date
): Promise<EventType[]> => {
  const accessToken = await getValidMicrosoftToken()
  if (!accessToken) throw new Error('Not authenticated with Microsoft')

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('User not authenticated')

  // Format dates for Microsoft Graph API (ISO 8601 format)
  const startDateTime = format(startDate, "yyyy-MM-dd'T'HH:mm:ss")
  const endDateTime = format(endDate, "yyyy-MM-dd'T'HH:mm:ss")

  // Use calendarView endpoint for efficient date filtering
  const url = new URL(`${GRAPH_API_BASE}/me/calendar/calendarView`)
  url.searchParams.append('startDateTime', startDateTime)
  url.searchParams.append('endDateTime', endDateTime)
  url.searchParams.append('$orderby', 'start/dateTime')
  url.searchParams.append('$top', '250') // Max results per page

  const response = await fetch(url.toString(), {
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Prefer': 'outlook.timezone="UTC"', // Request UTC times
    },
  })

  if (!response.ok) {
    await handleGraphError(response)
  }

  const data = await response.json()
  const microsoftEvents = data.value || []

  // Map Microsoft events to TimeFlow format
  const events: EventType[] = microsoftEvents.map((msEvent: any) => {
    // Handle all-day events vs timed events
    const isAllDay = msEvent.isAllDay || false
    const startTime = msEvent.start.dateTime
    const endTime = msEvent.end.dateTime

    return {
      id: '', // Will be generated by Supabase
      user_id: user.id,
      title: msEvent.subject || 'Untitled Event',
      description: msEvent.bodyPreview || msEvent.body?.content || null,
      start_time: startTime,
      end_time: endTime,
      all_day: isAllDay,
      location: msEvent.location?.displayName || null,
      microsoft_event_id: msEvent.id,
      google_event_id: null,
      google_calendar_id: null,
      synced_to_microsoft: true,
      synced_to_google: false,
      category: 'other' as const, // Deprecated field
      category_id: null,
      importance: 3,
      energy_level: null,
      color: null,
      attendees: msEvent.attendees?.map((a: any) => ({
        email: a.emailAddress?.address,
        name: a.emailAddress?.name,
        status: a.status?.response,
      })) || [],
      created_at: msEvent.createdDateTime || new Date().toISOString(),
      updated_at: msEvent.lastModifiedDateTime || new Date().toISOString(),
    } as EventType
  })

  return events
}

/**
 * Sync events from Microsoft Calendar to TimeFlow
 * @param startDate - Start date for sync range
 * @param endDate - End date for sync range
 * @returns Number of imported and total events
 */
export const syncFromMicrosoft = async (
  startDate?: Date,
  endDate?: Date
) => {
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('User not authenticated')

  // Default to 1 month before and after current date
  const now = new Date()
  const defaultStartDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)
  const defaultEndDate = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000)

  const start = startDate || defaultStartDate
  const end = endDate || defaultEndDate

  // Fetch events from Microsoft
  const microsoftEvents = await getMicrosoftEvents(start, end)

  // Get existing events from Supabase to avoid duplicates
  const { data: existingEvents } = await supabase
    .from('events')
    .select('microsoft_event_id')
    .eq('user_id', user.id)
    .not('microsoft_event_id', 'is', null)

  const existingMicrosoftIds = new Set(
    existingEvents?.map((e) => e.microsoft_event_id) || []
  )

  // Filter out events that already exist
  const newEvents = microsoftEvents.filter(
    (event) => !existingMicrosoftIds.has(event.microsoft_event_id)
  )

  // Insert new events
  if (newEvents.length > 0) {
    const { error } = await supabase.from('events').insert(newEvents)
    if (error) throw error
  }

  return { imported: newEvents.length, total: microsoftEvents.length }
}

/**
 * Create an event in Microsoft Calendar
 * @param event - TimeFlow event to create
 * @returns Microsoft event ID
 */
export const createMicrosoftEvent = async (
  event: EventType
): Promise<string | null> => {
  const accessToken = await getValidMicrosoftToken()
  if (!accessToken) {
    console.warn('Not authenticated with Microsoft')
    return null
  }

  // Convert TimeFlow event to Microsoft Graph format
  const microsoftEvent: any = {
    subject: event.title,
    body: {
      contentType: 'text',
      content: event.description || '',
    },
    start: {
      dateTime: event.all_day
        ? format(parseISO(event.start_time), 'yyyy-MM-dd')
        : event.start_time,
      timeZone: 'UTC',
    },
    end: {
      dateTime: event.all_day
        ? format(parseISO(event.end_time), 'yyyy-MM-dd')
        : event.end_time,
      timeZone: 'UTC',
    },
    isAllDay: event.all_day,
  }

  // Add optional fields
  if (event.location) {
    microsoftEvent.location = {
      displayName: event.location,
    }
  }

  if (event.attendees && event.attendees.length > 0) {
    microsoftEvent.attendees = event.attendees.map((attendee: any) => ({
      emailAddress: {
        address: attendee.email,
        name: attendee.name || attendee.email,
      },
      type: 'required',
    }))
  }

  const response = await fetch(`${GRAPH_API_BASE}/me/calendar/events`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(microsoftEvent),
  })

  if (!response.ok) {
    await handleGraphError(response)
  }

  const data = await response.json()
  return data.id
}

/**
 * Update an event in Microsoft Calendar
 * @param eventId - Microsoft event ID
 * @param event - Updated event data
 * @returns true if successful
 */
export const updateMicrosoftEvent = async (
  eventId: string,
  event: EventType
): Promise<boolean> => {
  const accessToken = await getValidMicrosoftToken()
  if (!accessToken) {
    console.warn('Not authenticated with Microsoft')
    return false
  }

  // Convert TimeFlow event to Microsoft Graph format
  const microsoftEvent: any = {
    subject: event.title,
    body: {
      contentType: 'text',
      content: event.description || '',
    },
    start: {
      dateTime: event.all_day
        ? format(parseISO(event.start_time), 'yyyy-MM-dd')
        : event.start_time,
      timeZone: 'UTC',
    },
    end: {
      dateTime: event.all_day
        ? format(parseISO(event.end_time), 'yyyy-MM-dd')
        : event.end_time,
      timeZone: 'UTC',
    },
    isAllDay: event.all_day,
  }

  // Add optional fields
  if (event.location) {
    microsoftEvent.location = {
      displayName: event.location,
    }
  }

  const response = await fetch(
    `${GRAPH_API_BASE}/me/calendar/events/${eventId}`,
    {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(microsoftEvent),
    }
  )

  if (!response.ok) {
    await handleGraphError(response)
  }

  return true
}

/**
 * Delete an event from Microsoft Calendar
 * @param eventId - Microsoft event ID
 * @returns true if successful
 */
export const deleteMicrosoftEvent = async (
  eventId: string
): Promise<boolean> => {
  const accessToken = await getValidMicrosoftToken()
  if (!accessToken) {
    console.warn('Not authenticated with Microsoft')
    return false
  }

  const response = await fetch(
    `${GRAPH_API_BASE}/me/calendar/events/${eventId}`,
    {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
      },
    }
  )

  if (!response.ok) {
    // 404 means event doesn't exist, which is acceptable for delete
    if (response.status === 404) {
      return true
    }
    await handleGraphError(response)
  }

  return true
}

/**
 * Get a list of available Microsoft calendars
 * @returns Array of calendar objects
 */
export const getMicrosoftCalendars = async () => {
  const accessToken = await getValidMicrosoftToken()
  if (!accessToken) throw new Error('Not authenticated with Microsoft')

  const response = await fetch(`${GRAPH_API_BASE}/me/calendars`, {
    headers: {
      'Authorization': `Bearer ${accessToken}`,
    },
  })

  if (!response.ok) {
    await handleGraphError(response)
  }

  const data = await response.json()
  return data.value || []
}

/**
 * Batch update: Create or update multiple events in Microsoft Calendar
 * @param events - Array of TimeFlow events
 * @returns Array of Microsoft event IDs
 */
export const batchSyncToMicrosoft = async (
  events: EventType[]
): Promise<Array<{ localId: string; microsoftId: string | null }>> => {
  const results = []

  for (const event of events) {
    try {
      if (event.microsoft_event_id) {
        // Update existing event
        await updateMicrosoftEvent(event.microsoft_event_id, event)
        results.push({ localId: event.id, microsoftId: event.microsoft_event_id })
      } else {
        // Create new event
        const microsoftId = await createMicrosoftEvent(event)
        results.push({ localId: event.id, microsoftId })

        // Update local event with Microsoft ID
        if (microsoftId) {
          await supabase
            .from('events')
            .update({
              microsoft_event_id: microsoftId,
              synced_to_microsoft: true,
            })
            .eq('id', event.id)
        }
      }
    } catch (error) {
      console.error(`Failed to sync event ${event.id}:`, error)
      results.push({ localId: event.id, microsoftId: null })
    }
  }

  return results
}
